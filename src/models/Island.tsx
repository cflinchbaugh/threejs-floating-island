/*
Initially Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: nimzu (https://sketchfab.com/nimzuk)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/foxs-islands-163b68e09fcc47618450150be7785907
Title: Fox's islands
*/

import { useGLTF } from "@react-three/drei";
import { useCallback, useEffect, useRef } from "react";
import { a } from "@react-spring/three";

import islandScene from "../assets/3d/island.glb";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";

import type { Position } from "../pages/Home";

const stageRanges = [
  { min: 4.25, max: 4.75, stage: 1 },
  { min: 2.4, max: 2.6, stage: 2 },
  { min: 0.85, max: 1.3, stage: 3 },
  { min: 5.45, max: 5.85, stage: 4 },
];

type IslandProps = {
  isRotating: boolean;
  setIsRotating: (val: boolean) => void;
  setCurrentStage: (val: number | null) => void;
  scale: Position;
  position: Position;
  rotation: Position;
};
const Island = ({
  isRotating,
  setIsRotating,
  setCurrentStage,
  ...props
}: IslandProps) => {
  const { nodes, materials } = useGLTF(islandScene) as unknown as {
    nodes: Record<string, THREE.Mesh>;
    materials: Record<string, THREE.Material>;
  };

  const islandRef = useRef<THREE.Group>(null);

  const { gl } = useThree();
  const lastX = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95;

  const handlePointerDown = useCallback(
    (e: MouseEvent | TouchEvent) => {
      e.stopPropagation();
      e.preventDefault();
      setIsRotating(true);

      const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
      lastX.current = clientX;
    },
    [setIsRotating]
  );

  const handlePointerUp = useCallback(
    (e: MouseEvent | TouchEvent) => {
      e.stopPropagation();
      e.preventDefault();
      setIsRotating(false);
    },
    [setIsRotating]
  );

  const handlePointerMove = useCallback(
    (e: MouseEvent | TouchEvent) => {
      e.stopPropagation();
      e.preventDefault();

      if (isRotating) {
        const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
        const delta = (clientX - lastX.current) * 0.005;

        if (islandRef.current !== null) {
          islandRef.current.rotation.y += delta;
        }
        lastX.current = clientX;
        rotationSpeed.current = delta * 0.01 * Math.PI;
      }
    },
    [isRotating]
  );

  const keysPressedRef = useRef<{ left: boolean; right: boolean }>({
    left: false,
    right: false,
  });

  const handleKeyChange = useCallback(
    (e: KeyboardEvent, isPressed: boolean) => {
      if (e.key === "ArrowLeft") keysPressedRef.current.left = isPressed;
      if (e.key === "ArrowRight") keysPressedRef.current.right = isPressed;
    },
    []
  );

  useEffect(() => {
    const canvas = gl.domElement;

    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointerup", handlePointerUp);
    canvas.addEventListener("pointermove", handlePointerMove);
    canvas.addEventListener("touchmove", handlePointerMove, { passive: false });

    document.addEventListener("keydown", (e) => handleKeyChange(e, true));
    document.addEventListener("keyup", (e) => handleKeyChange(e, false));

    return () => {
      canvas.removeEventListener("pointerdown", handlePointerDown);
      canvas.removeEventListener("pointerup", handlePointerUp);
      canvas.removeEventListener("pointermove", handlePointerMove);
      canvas.removeEventListener("touchmove", handlePointerMove);

      document.removeEventListener("keydown", (e) => handleKeyChange(e, true));
      document.removeEventListener("keyup", (e) => handleKeyChange(e, false));
    };
  }, [
    gl,
    handleKeyChange,
    handlePointerDown,
    handlePointerUp,
    handlePointerMove,
  ]);

  useFrame(() => {
    if (islandRef.current === null) return;

    if (keysPressedRef.current.left) {
      islandRef.current.rotation.y += 0.01 * Math.PI;
    }
    if (keysPressedRef.current.right) {
      islandRef.current.rotation.y -= 0.01 * Math.PI;
    }

    if (!isRotating) {
      rotationSpeed.current *= dampingFactor;

      if (Math.abs(rotationSpeed.current) < 0.001) {
        rotationSpeed.current = 0;
      }

      islandRef.current.rotation.y += rotationSpeed.current;
    } else {
      const rotation = islandRef.current?.rotation.y;

      if (!rotation) return;

      /**
       * Normalize the rotation value to ensure it stays within the range [0, 2 * Math.PI].
       * The goal is to ensure that the rotation value remains within a specific range to
       * prevent potential issues with very large or negative rotation values.
       *  Here's a step-by-step explanation of what this code does:
       *  1. rotation % (2 * Math.PI) calculates the remainder of the rotation value when divided
       *     by 2 * Math.PI. This essentially wraps the rotation value around once it reaches a
       *     full circle (360 degrees) so that it stays within the range of 0 to 2 * Math.PI.
       *  2. (rotation % (2 * Math.PI)) + 2 * Math.PI adds 2 * Math.PI to the result from step 1.
       *     This is done to ensure that the value remains positive and within the range of
       *     0 to 2 * Math.PI even if it was negative after the modulo operation in step 1.
       *  3. Finally, ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI) applies another
       *     modulo operation to the value obtained in step 2. This step guarantees that the value
       *     always stays within the range of 0 to 2 * Math.PI, which is equivalent to a full
       *     circle in radians.
       */
      // const normalizedRotation =
      //   ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

      let normalizedRotation = rotation % (2 * Math.PI);
      if (normalizedRotation < 0) normalizedRotation += 2 * Math.PI;

      const matchedStage =
        stageRanges.find(
          ({ min, max }) =>
            normalizedRotation >= min && normalizedRotation <= max
        )?.stage || null;

      setCurrentStage(matchedStage);
    }
  });

  return (
    <a.group {...props} ref={islandRef}>
      <mesh
        geometry={nodes.polySurface944_tree_body_0.geometry}
        material={materials.PaletteMaterial001}
      />
      <mesh
        geometry={nodes.polySurface945_tree1_0.geometry}
        material={materials.PaletteMaterial001}
      />
      <mesh
        geometry={nodes.polySurface946_tree2_0.geometry}
        material={materials.PaletteMaterial001}
      />
      <mesh
        geometry={nodes.polySurface947_tree1_0.geometry}
        material={materials.PaletteMaterial001}
      />
      <mesh
        geometry={nodes.polySurface948_tree_body_0.geometry}
        material={materials.PaletteMaterial001}
      />
      <mesh
        geometry={nodes.polySurface949_tree_body_0.geometry}
        material={materials.PaletteMaterial001}
      />
      <mesh
        geometry={nodes.pCube11_rocks1_0.geometry}
        material={materials.PaletteMaterial001}
      />
    </a.group>
  );
};

useGLTF.preload("/island.glb");

export default Island;
